Title: Установка нескольких версий Python параллельно при помощи pyenv
Tags: python, pyenv
Summary: Простое управление версиями интерпретатора.
Header_cover: /static/snakes.jpg
Status: published

В большинстве операционных систем Python предустановлен
(ну, кроме Windows, но даже там теперь есть
[команда `python`, которая предложит установить интерпретатор из магазина приложений](
https://devblogs.microsoft.com/python/python-in-the-windows-10-may-2019-update/)).
В Unix-подобных операционных системах, таких как Linux и MacOS, Python
пустил корни очень глубоко. Множество компонентов ОС рассчитывают, что Python
установлен и работает стабильно. Это и хорошо, и плохо.

Это хорошо, потому что хотя бы какой-то Python в большинстве систем доступен из
коробки — бери и пользуйся. Иногда доступно сразу несколько версий
интерпретатора, например, `python2` указывает на устаревшую версию 2.7,
`python3` — на какую-нибудь стабильную версию Python 3, типа 3.6 или 3.7, а
просто `python` указывает либо на одно, либо на другое (в последнее время
предпочтение чаще отдаётся третьей версии). Для обучения или для
тестирования этого может быть вполне достаточно.

С другой стороны, это плохо, потому что, как правило, предустановленный Python
настолько стабилен, что уже успел зарасти мхом.
В некоторых системах до сих пор предустановлен только Python 2,
но даже если вам повезёт получить Python третьей версии,
то наверняка он будет отставать от последней версии на пару минорных релизов.
Не факт, что вам это подойдёт.

Иногда нужно иметь сразу несколько версий Python для работы над
разными проектами, например, 3.7 и 3.8. В некоторых ОС нужные версии можно
установить через пакетный менеджер (например, в [Fedora через dnf](https://developer.fedoraproject.org/tech/languages/python/multiple-pythons.html))
— из основных репозиториев или из сторонних.
Но зачастую такие репозитории содержат не все релизы
интерпретаторов, а лишь выбранное мейнтейнерами репозиториев подмножество.

Решение у всех этих проблем одно — нужно установить недостающие версии
интерпретатора, какими бы они ни были. Этому и посвящён пост.

# pyenv

[`pyenv`](https://github.com/pyenv/pyenv) — утилита, которая позволяет
легко переключаться между несколькими версиями интерпретатора Python, а
также устанавливать новые. Позволяет устанавливать, наверное, вообще
все известные науке версии интерпретаторов Python. Работает просто и незаметно. 

`pyenv` — это всего лишь один из последователей аналогичного инструмента
из мира Ruby — [`rbenv`](https://github.com/rbenv/rbenv).
Есть ещё и [`nodenv`](https://github.com/nodenv/nodenv) для Node.js,
который тоже вдохновился `rbenv`.

Проект написан целиком на `bash`. Это значит, что он никак не зависит
от Python — было бы забавно, если бы для установки Python нужен был бы Python.
Также это означает, что на Windows `pyenv` работать не будет
([тред с обсуждением](https://github.com/pyenv/pyenv/issues/62)),
но есть форк — [`pyenv-win`](https://github.com/pyenv-win/pyenv-win),
который пытается заимплементить ту же функциональность на `.bat`-скриптах 
(пока что работает только часть команд). Пользователи современных версий
Windows могут использовать `pyenv` внутри WSL (Windows Subsystem for Linux).
Ещё это означает, что у авторов много отваги — я бы не решился писать
на `bash` что-то настолько сложное. Как же хорошо, что всё уже написано.

## Установка

1. Скачаем `pyenv`.

    Установка `pyenv` производится простым клонированием git-репозитория.
    
    У проекта есть [умный скрипт](https://github.com/pyenv/pyenv-installer),
    который скачает `pyenv` и его сотоварищей:
    
        $ curl https://pyenv.run | bash
    
    Скрипт не требует прав суперпользователя (без `sudo`), потому что
    всё устанавливается в домашнюю директорию пользователя. Туда же
    будут устанавливаться и интерпретаторы. Если страшно запускать
    какие-то скрипты из интернета (так и должно быть), то прочитать код скрипта можно
    [здесь](https://github.com/pyenv/pyenv-installer/blob/master/bin/pyenv-installer).

2. Настроим шелл.

    Предыдущая команда перед завершением должна была напечатать инструкции
    по настройке шелла. Допустим, в случае с `bash` она выводит
    следующее:
    
        WARNING: seems you still have not added 'pyenv' to the load path.
        
        # Load pyenv automatically by adding
        # the following to ~/.bashrc:
        
        export PATH="~/.pyenv/bin:$PATH"
        eval "$(pyenv init -)"
        eval "$(pyenv virtualenv-init -)"
    
    В случае с `zsh` нужно будет добавить те же самые строки в `~/.zshrc`.
    
    В случае с `fish` в связи с особенностями самого шелла инструкции отличаются:
    
        # Load pyenv automatically by adding
        # the following to ~/.config/fish/config.fish:
        
        set -x PATH "~/.pyenv/bin" $PATH
        status --is-interactive; and . (pyenv init -|psub)
        status --is-interactive; and . (pyenv virtualenv-init -|psub)
    
    Кстати, горячо рекомендую попробовать [`fish`](https://fishshell.com/), очень удобный шелл.

3. Установим зависимости для сборки.

    При установке новой версии интерпретатора через `pyenv` под капотом
    происходит сборка из исходников, поэтому для успешной установки
    необходимы некоторые зависимости. Полный и актуальный список
    для своей ОС смотрите [здесь](
    https://github.com/pyenv/pyenv/wiki#suggested-build-environment)
    или [здесь](https://github.com/pyenv/pyenv/wiki/common-build-problems#prerequisites).
    Лучше установить всё заранее.
    
4. Перезапустим шелл и проверим установку.

        $ pyenv --version
        pyenv 1.2.18
        
## Как это работает

`pyenv` работает благодаря манипуляциям над переменной окружения `$PATH`.
Эта переменная содержит в себе список директорий, в которых ОС будет искать
исполняемые файлы, вызванные без указания полного пути. Именно
благодаря этой переменной мы можем в терминале вместо `/bin/cat` вызывать
просто `cat`. Когда мы набираем в терминале имя программы (`cat`),
ОС перебирает директории из `$PATH` слева направо, пока в одной
из них (в данном примере `/bin`) не найдёт программу с именем `cat`,
которую и запустит. Поиск прекращается после первого совпадения.

Команда `pyenv init -`, которую мы добавили в конфиг шелла (`.bashrc` или аналог)
добавляет директории `pyenv` в самое начало переменной `$PATH`.
Зачем это нужно? `pyenv` создаёт небольшие исполняемые файлы,
так называемые файлы-прослойки (shims), для всех команд,
которыми он собирается управлять, например, `python`, `pip`, `ipython` и так далее.
Эти файлы-прослойки должны попасть в `$PATH` прежде самих управляемых программ
и "затенить" системные `python`, `pip` и так далее.
Эти файлы-прослойки в конечном счёте просто вызывают сам `pyenv`
с нужными аргументами.
Таким образом `pyenv` перехватывает обращения к некоторым именам,
и анализируя поступившую к нему информацию,
принимает решение о том, какую именно версию Python нужно запустить.
При выборе версии `pyenv` принимает во внимание следующие факторы в
указанном порядке:

1. Переменная окружения `PYENV_VERSION`, если указана.

    В неё можно указать какую конкретно версию Python нужно использовать
    в рамках текущего сеанса. Удобно, если вам по какой-то причине понадобится
    сменить выбранную версию интерпретатора, например, в одном
    из окон терминала.

2. Локальная версия Python.

    При помощи специального файла `.python-version` можно настроить
    версию интерпретатора для определенного проекта. Захо́дите внутрь
    директории (`cd project/`), и `pyenv` внезапно понимает, что нужно
    сменить Python. Выхо́дите обратно — версия Python меняется на глобальную.
    Это распространяется и на все поддиректории проекта —
    `pyenv` рекурсивно ищет файл `.python-version` вверх по файловой системе,
    пока не дойдёт до корня.

3. Глобальная версия Python.

    В файле `~/.pyenv/version` записана глобальная версия Python, которая
    будет использоваться по умолчанию, если не сконфигурирована локальная
    версия.
    
Вам вряд ли придётся вручную трогать эти файлы, потому что у `pyenv` есть
удобные команды (`pyenv local` и `pyenv global`),
чтобы ими управлять, но знать о файлах всё равно полезно.

## Использование

### Установка новой версии Python

Сначала посмотрим, какие версии Python `pyenv` может установить:

```sh
$ pyenv install --list
...
3.6.0
3.6-dev
3.6.1
3.6.2
3.6.3
3.6.4
3.6.5
3.6.6
3.6.7
3.6.8
3.6.9
3.6.10
3.7.0
3.7-dev
3.7.1
3.7.2
3.7.3
3.7.4
3.7.5
3.7.6
3.7.7
3.8.0
3.8-dev
3.8.1
3.8.2
3.9.0a6
3.9-dev
...
```

Список довольно длинный, поэтому я его подсократил. Обычно вас будут
интересовать такие версии, как `3.8.2` или `3.7.7` — это версии самой
распространённой реализации интерпретатора CPython. Но если
вам нужна экзотика, то `pyenv` умеет устанавливать любые сорта интерпретаторов
Python (`pypy3.6-7.3.0`, `stackless-3.7.5`, `jython-2.7.1`,
`ironpython-2.7.7`, `micropython-1.12` и т.д.). Для вас ведь не стало
новостью, что существует много разных реализаций интерпретатора Python?

Установим CPython 3.8.2:

```sh
$ pyenv install 3.8.2
Downloading Python-3.8.2.tar.xz...
Installing Python-3.8.2...
```

Через пару минут ожидания ваш новоиспечённый Python будет готов.

Можно сразу же назначить эту версию глобальной:

```sh
$ pyenv global 3.8.2
$ python -V
Python 3.8.2
```

Давайте в целях демонстрации установим ещё парочку интерпретаторов:

```sh
$ pyenv install 2.7.18
$ pyenv install 3.9.0a6
```

Получим список установленных версий интерпретатора:

```sh
$ pyenv versions
  2.7.18
* 3.8.2 (set by /home/br0ke/.pyenv/version)
  3.9.0a6
```

Кстати, если нужно, то можно делать активными сразу несколько
версий одновременно:

```sh
$ pyenv global 3.8.2 2.7.18
```

Теперь вывод версий покажет следующее:

```sh
$ pyenv versions
* 2.7.18 (set by /home/br0ke/.pyenv/version)
* 3.8.2 (set by /home/br0ke/.pyenv/version)
  3.9.0a6
```

А работать это будет вот таким образом:

```sh
$ python -V
Python 3.8.2
$ python3 -V
Python 3.8.2
$ python2 -V
Python 2.7.18
```

Грубо говоря, та версия, которая указана первой (3.8.2),
имеет приоритет и занимает все нужные ей имена. Следующие версии (2.7.18)
могут занять любые оставшиеся свободные имена (в данном случае, это только имя
`python2`).

А файл глобальной версии `~/.pyenv/version` на данный момент имеет вот
такое содержимое:

```sh
$ cat ~/.pyenv/version
3.8.2
2.7.18
```

### Локальная версия

Давайте создадим директорию и войдём в неё:

```sh
$ mkdir my_project
$ cd my_project
```

Представим, что в этой директории мы будем разрабатывать некий
проект, на котором мы хотим опробовать фишки нового Python 3.9.
Сообщим об этом `pyenv`:

```sh
$ pyenv local 3.9.0a
```

В директории появился файл `.python-version` со следующим содержимым:

```sh
$ cat .python-version
3.9.0a6
```

На данный момент список версий показывает следующее (удобно использовать
эту команду, чтобы понять какую версию и почему `pyenv` активирует):

```sh
$ pyenv versions
  2.7.18
  3.8.2
* 3.9.0a6 (set by /home/br0ke/my_project/.python-version)
```

Изменения немедленно вступили в силу:

```sh
$ python -V
Python 3.9.0a6
```

Но эта конфигурация никак не влияет на работу `pyenv` вне директории проекта:

```sh
$ cd ..
$ python -V
3.8.2
```

Как и в случае с глобальной конфигурацией, можно локально активировать
сразу несколько версий интерпретатора.

### Установим IPython

Часто бывает нужно установить какой-нибудь пакет так, чтобы он тоже
стал доступен из командной строки. Допустим, что нам нужно установить
[`ipython`](https://ipython.org/) — более удобную версию REPL Python.
Сделаем это:

```sh
$ cd my_project
$ pip install ipython
```

Запустим:

```sh
$ ipython
Python 3.9.0a6 (default, May  3 2020, 16:58:20)
Type 'copyright', 'credits' or 'license' for more information
IPython 7.14.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]:
```

Программа сразу доступна, благодаря тому, что `pyenv` очень умный и
создал новый файл-прослойку (shim) автоматически:

```sh
$ which ipython
/home/br0ke/.pyenv/shims/ipython
```

Вне директории с проектом `ipython` будет недоступен, ведь он же установлен
в локальный интерпретатор `3.9.0a6`, а снаружи активирован другой
интерпретатор — можете проверить самостоятельно.

Возникают ситуации, когда по какой-то причине прослойка не создалась
или с ней случилось что-то ещё, например, удалилась:

```sh
$ rm $(which ipython)
$ ipython
No such file or directory
```

Не беда! Можно попросить `pyenv` пересоздать их все заново:

```sh
$ pyenv rehash
```

И всё работает снова:

```sh
$ ipython
Python 3.9.0a6 (default, May  3 2020, 16:58:20)
Type 'copyright', 'credits' or 'license' for more information
IPython 7.14.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]:
```

Можно вообще добавить команду `pyenv rehash` в свой `~/.bashrc` (или аналог),
чтобы при запуске шелла гарантированно иметь рабочие файлы-прослойки (shims).

## Заключение

`pyenv` — очень удобный и полезный инструмент в ситуациях, когда нужную вам
версию Python нельзя установить средствами операционной системы.
Я вообще предпочитаю устанавливать все нужные мне версии интерпретатора
самостоятельно через `pyenv` или `asdf`, даже если ОС уже содержит точно
такую же версию — пусть ОС использует свою копию для служебных целей,
а я для разработки буду использовать свою собственную копию, где смогу
проводить любые кровавые эксперименты, не боясь поломать ОС.

Обязательно
[подпишитесь на уведомления]({filename}../pages/subscribe.md)
о новых постах в блоге, чтобы ничего не пропустить!

## Дополнительное чтение

* [Репозиторий проекта на GitHub](https://github.com/pyenv/pyenv);
* [Туториал на RealPython](https://realpython.com/intro-to-pyenv/);
* [Альтернатива: универсальный менеджер версий `asdf`](https://asdf-vm.com/#/).
